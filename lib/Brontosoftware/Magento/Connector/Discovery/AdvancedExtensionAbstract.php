<?php
/**
 * This file was generated by the ConvertToLegacy class in bronto-legacy.
 * The purpose of the conversion was to maintain PSR-0 compliance while
 * the main development focuses on modern styles found in PSR-4.
 *
 * For the original:
 * @see src/Bronto/Magento/Connector/Discovery/AdvancedExtensionAbstract.php
 */

abstract class Brontosoftware_Magento_Connector_Discovery_AdvancedExtensionAbstract extends Brontosoftware_Magento_Connector_Discovery_ExtensionPushEventAbstract implements Brontosoftware_Magento_Connector_Discovery_AdvancedExtensionInterface
{
    protected $_appEmulation;

    /**
     * @param Brontosoftware_Magento_Core_Store_ManagerInterface $storeManager
     * @param Brontosoftware_Magento_Connector_QueueManagerInterface $queueManager
     * @param Brontosoftware_Magento_Connector_SettingsInterface $connectorSettings
     * @param Brontosoftware_Magento_Connector_Event_HelperInterface $helper
     * @param Brontosoftware_Magento_Connector_Event_PlatformInterface $platform
     * @param Brontosoftware_Magento_Connector_Event_SourceInterface $source
     */
    public function __construct(
        Brontosoftware_Magento_Core_App_EmulationInterface $appEmulation,
        Brontosoftware_Magento_Core_Store_ManagerInterface $storeManager,
        Brontosoftware_Magento_Connector_QueueManagerInterface $queueManager,
        Brontosoftware_Magento_Connector_SettingsInterface $connectorSettings,
        Brontosoftware_Magento_Connector_Event_HelperInterface $helper,
        Brontosoftware_Magento_Connector_Event_PlatformInterface $platform,
        Brontosoftware_Magento_Connector_Event_SourceInterface $source
    ) {
        parent::__construct(
            $storeManager,
            $queueManager,
            $connectorSettings,
            $helper,
            $platform,
            $source);
        $this->_appEmulation = $appEmulation;
    }

    /**
     * Performs a test import based on user defined input
     *
     * @param mixed $observer
     * @return void
     */
    public function testImport($observer)
    {
        $registration = $observer->getScript()->getRegistration();
        $script = $observer->getScript()->getObject();
        $events = array();
        $objects = $this->_sendTest($registration, $script['data']);
        $source = $this->_source($script['data']);
        foreach ($objects as $object) {
            $this->_appEmulation->startEnvironmentEmulation($object->getStoreId(), 'frontend', true);
            $store = $this->_storeManager->getStore($object->getStoreId());
            $action = $source->action($object);
            $action = empty($action) ? 'add' : $action;
            $event = $this->_platform->annotate($source, $object, $action, $store);
            $this->_appEmulation->stopEnvironmentEmulation();
            if (array_key_exists('performImport', $script['data']) && $script['data']['performImport']) {
                $this->_platform->dispatch($event);
            }
            $events[] = $event['data'];
        }
        $observer->getScript()->setResults($events);
    }

    /**
     * Performs a historical import based on user defined input
     *
     * @param mixed $observer
     * @return void
     */
    public function historicalImport($observer)
    {
        $registration = $observer->getScript()->getRegistration();
        $script = $observer->getScript()->getObject();
        $numbers = array(
            'processed' => 0,
            'success' => 0,
            'error' => 0,
            'skipped' => 0
        );
        $events = array();
        $output = array_key_exists('output', $script['data']['options']) && $script['data']['options']['output'];
        $objects = $this->_sendHistorical($registration, $script['data']);
        $source  = $this->_source($script['data']);
        foreach ($this->_limitOffset($objects, $script['data']) as $object) {
            $action = $this->_historicalAction($script['data'], $object);
            if (!empty($action)) {
                $this->_appEmulation->startEnvironmentEmulation($object->getStoreId(), 'frontend', true);
                $store = $this->_storeManager->getStore($object->getStoreId());
                $event = $this->_platform->annotate($source, $object, $action, $store);
                $events[] = $event['data'];
                $this->_appEmulation->stopEnvironmentEmulation();
                if ($output || $this->_platform->dispatch($event)) {
                    $numbers['success']++;
                } else {
                    $numbers['error']++;
                }
            } else {
                $numbers['skipped']++;
            }
            $numbers['processed']++;
        }
        $script['data']['size'] = $numbers['processed'];
        if (empty($script['data']['options'])) {
            unset($script['data']['options']);
        }
        $results = array('results' => $observer->getScript()->createProgresses($numbers));
        if ($output) {
            $results['events'] = $events;
        }
        $observer->getScript()->setResults(array_merge($script['data'], $results));
    }

    /**
     * Applies the limit and offset rules for input data
     *
     * @param Iterator $objects
     * @param array $data
     * @return Iterator
     */
    protected function _limitOffset($objects, $data)
    {
        $page = 1;
        if (array_key_exists('page', $data)) {
            $page = $data['page'];
        }
        $perPage = 20;
        if (array_key_exists('size', $data)) {
            $perPage = $data['size'];
        }
        return $this->_applyLimitOffset($objects, $perPage, $page);
    }

    /**
     * Applies the LIMIT and OFFSET to the appropriate collection
     *
     * @param mixed $objects
     * @param int $limit
     * @param int $offset
     * @return mixed
     */
    protected function _applyLimitOffset($objects, $limit, $offset)
    {
        $objects->getSelect()->limitPage($offset, $limit);
        return $objects;
    }

    /**
     * Intended to allow for implementors to override the default action
     *
     * @param mixed $data
     * @param mixed $object
     * @return string
     */
    protected function _historicalAction($data, $object)
    {
        return $this->_source($data)->action($object);
    }

    /**
     * Intended to swap out the source if duality is used
     *
     * @param array $data
     * @return Brontosoftware_Magento_Connector_Event_SourceInterface
     */
    protected function _source($data)
    {
        return $this->_source;
    }

    /**
     * Implementors would return a collection that satisfies the constraints
     * supplied in as the data array
     *
     * @param Brontosoftware_Magento_Connector_RegistrationInterface $registration
     * @param array $data
     * @return Iterator
     */
    abstract protected function _sendTest($registration, $data);

    /**
     * Implementors would return a collection that satisfies the contraints
     * supplied in as the data array
     *
     * @param Brontosoftware_Magento_Connector_RegistrationInterface $registration
     * @param array $data
     * @return Iterator
     */
    abstract protected function _sendHistorical($registration, $data);
}
