<?php
/**
 * This file was generated by the ConvertToLegacy class in bronto-legacy.
 * The purpose of the conversion was to maintain PSR-0 compliance while
 * the main development focuses on modern styles found in PSR-4.
 *
 * For the original:
 * @see src/Bronto/Magento/Email/Trigger/Observer.php
 */

class Brontosoftware_Magento_Email_Trigger_Observer
{
    protected $_triggerManager;
    protected $_helper;
    protected $_connectorSettings;
    protected $_productRepo;
    protected $_settings;
    protected $_siteId;
    protected $_customerRepo;

    /**
     * @param Brontosoftware_Magento_Email_TriggerManagerInterface $triggerManager
     * @param Brontosoftware_Magento_Email_SettingsInterface $helper
     * @param Brontosoftware_Magento_Connector_SettingsInterface $connectorSettings
     * @param Brontosoftware_Magento_Core_Catalog_ProductCacheInterface $productRepo
     * @param Brontosoftware_Magento_Core_Customer_CacheInterface $customerRepo
     * @param Brontosoftware_Magento_Integration_CartSettingsInterface $settings
     */
    public function __construct(
        Brontosoftware_Magento_Email_TriggerManagerInterface $triggerManager,
        Brontosoftware_Magento_Email_SettingsInterface $helper,
        Brontosoftware_Magento_Connector_SettingsInterface $connectorSettings,
        Brontosoftware_Magento_Core_Catalog_ProductCacheInterface $productRepo,
        Brontosoftware_Magento_Core_Customer_CacheInterface $customerRepo,
        Brontosoftware_Magento_Integration_CartSettingsInterface $settings
    ) {
        $this->_triggerManager = $triggerManager;
        $this->_helper = $helper;
        $this->_connectorSettings = $connectorSettings;
        $this->_productRepo = $productRepo;
        $this->_settings = $settings;
        $this->_customerRepo = $customerRepo;
    }

    /**
     * Whenever a cart updates, update Reminder triggers
     *
     * @param mixed $observer
     * @return void
     */
    public function updateQuoteTrigger($observer)
    {
        $quote = $observer->getQuote();
        if (0 == $quote->getIsActive() || 0 == $quote->getItemsCount()) {
            $this->removeQuoteTrigger($observer);
        } else {
            $this->_handleReminder('cart', $quote);
        }
    }

    /**
     * Whever a wishlist updates, update Reminder triggers
     *
     * @param mixed $observer
     * @return void
     */
    public function updateWishlistTrigger($observer)
    {
        $wishlist = $observer->getObject();
        if (0 === $wishlist->getItemCollection()->getSize()) {
            $this->removeWishlistTrigger($observer);
        } else {
            $this->_handleReminder('wishlist', $wishlist);
        }
    }

    /**
     * Whenever an order is updated, scan applicable triggers
     *
     * @param mixed $observer
     * @return void
     */
    public function updateOrderTrigger($observer)
    {
        $order = $observer->getOrder();
        // When an order is saved, NOT coming from a placement, we must skip
        if ($order->getStatus() == 'pending' && is_null($order->getOrigData('status')) && !$observer->hasQuote()) {
            return;
        }
        list($orderType, $orderId) = $this->_helper->getModelTuple($order);
        if ($order->dataHasChangedFor('status')) {
            $messageTypes = array();
            foreach (array('reorder', 'caretip') as $type) {
                if ($this->_helper->isMessageEnabled($type, 'store', $order->getStoreId())) {
                    $messageTypes[$type] = $this->_helper->getActiveObjects($type, $order->getStore());
                }
            }
            $review = $this->_helper->getMessage('review', 'review', $order->getStore());
            $existingReviews = $this->_triggerManager->getTriggers($this->getSiteId($order->getStoreId()), $orderType, $orderId);
            if (!empty($review)) {
                $messageTypes['review'] = array('review' => $review);
            }
            if (!empty($messageTypes)) {
                $groupId = (int) $order->getCustomerGroupId();
                $reviewTriggered = false;
                foreach ($order->getAllVisibleItems() as $lineItem) {
                    list($modelType, $modelId) = $this->_helper->getModelTuple($lineItem);
                    $existingTriggers = $existingReviews + $this->_triggerManager->getTriggers($this->getSiteId($order->getStoreId()), $modelType, $modelId);
                    $product = $this->_productRepo->getById($lineItem->getProductId(), $order->getStoreId());
                    foreach ($messageTypes as $messageType => $objects) {
                        if ($reviewTriggered && $messageType == 'review') {
                            continue;
                        }
                        foreach ($objects as $objectId => $object) {
                            foreach ($product->getCategoryIds() as $catgoryId) {
                                if (!in_array($groupId, $object['targetAudience'])) {
                                    continue 2;
                                }
                                if (isset($object['exclusionCategories']) && in_array($catgoryId, $object['exclusionCategories']))  {
                                    continue 2;
                                }
                                if (empty($object['categories']) || in_array($catgoryId, $object['categories'])) {
                                    $this->_handlePostPurchase(
                                        $order,
                                        $messageType,
                                        $existingTriggers,
                                        $objectId,
                                        $object,
                                        $objectId == 'review' ? $orderType : $modelType,
                                        $objectId == 'review' ? $orderId : $modelId,
                                        $lineItem->getQtyOrdered());
                                    if ($objectId == 'review') {
                                        $reviewTriggered = true;
                                    }
                                    continue 2;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    /**
     * Deletes all of the triggers associated with a wishlist
     *
     * @param mixed $observer
     * @return void
     */
    public function removeWishlistTrigger($observer)
    {
        $this->_deleteModelTrigger($observer->getObject());
    }

    /**
     * Deletes all of the triggers associated with a quote
     *
     * @param mixed $observer
     * @return void
     */
    public function removeQuoteTrigger($observer)
    {
        $this->_deleteModelTrigger($observer->getQuote());

    }

    /**
     * Deletes all of the triggers associated with an order
     *
     * @param mixed $observer
     * @return void
     */
    public function removeOrderTrigger($observer)
    {
        $order = $this->_deleteModelTrigger($observer->getOrder());
        foreach ($order->getAllVisibleItems() as $lineItem) {
            $this->_deleteModelTrigger($lineItem);
        }
    }

    /**
     * Stores a reminder trigger for a cart or a wishlist
     *
     * @param string $modelType
     * @param mixed $model
     * @return void
     */
    protected function _handleReminder($modelType, $model)
    {
        if ($modelType == 'cart') {
            $emailAddress = $model->getCustomerEmail();
            $storeId = $model->getStore()->getId();
            if (empty($emailAddress)) {
                $emailAddress = $this->_settings->getCartRecoveryEmail($model);
                if (empty($emailAddress)) {
                    return;
                }
            }
        } else {
            $customer = $this->_customerRepo->getById($model->getCustomerId());
            if (empty($customer)) {
                return;
            }
            $storeId = $customer->getStore()->getId();
            $emailAddress = $customer->getEmail();
        }
        $existingTriggers = $this->_triggerManager->getTriggers($this->getSiteId($storeId), $modelType, $model->getId());
        $reminders = $this->_helper->getActiveObjects($modelType, $storeId);
        $updatedAt = $model->getUpdatedAt() ? $model->getUpdatedAt() : $model->getCreatedAt();
        $updatedAt = strtotime($updatedAt);
        foreach ($reminders as $reminderId => $reminder) {
            // Will want to exclude carts without emails
            if ($modelType == 'cart' && !in_array($model->getCustomerGroupId(), $reminder['targetAudience'])) {
                continue;
            }
            $trigger = $this->_triggerManager->createTrigger($this->getSiteId($storeId), $modelType, $reminderId);
            if (array_key_exists($reminderId, $existingTriggers)) {
                $trigger = $existingTriggers[$reminderId];
                if ($trigger->getSentMessage()) {
                    continue;
                }
            }
            $newTime = strtotime("+{$reminder['abandonPeriod']} {$reminder['abandonUnit']}", $updatedAt);
            if (isset($reminder['previousMessage'])) {
                if (!array_key_exists($reminder['previousMessage'], $existingTriggers)) {
                    continue;
                }
                $previous = $reminders[$reminder['previousMessage']];
                $newTime = strtotime("+{$previous['abandonPeriod']} {$previous['abandonUnit']}", $newTime);
            }
            $this->_triggerManager->save($trigger
                ->setCustomerEmail($emailAddress)
                ->setTriggeredAt($newTime)
                ->setModel($modelType, $model->getId(), $storeId));
            $existingTriggers[$reminderId] = $trigger;
        }
    }

    /**
     * Lots of entries for post purchase handles
     *
     * @param mixed $order
     * @param string $messageType
     * @param array $existingTriggers
     * @param string $objectId
     * @param array $object
     * @param string $modelType
     * @param mixed $modelId
     * @param int $qtyOrdered
     * @return void
     */
    protected function _handlePostPurchase($order, $messageType, $existingTriggers, $objectId, $object, $modelType, $modelId, $qtyOrdered)
    {
        $updatedAt = strtotime($order->getUpdatedAt() ?
            $order->getUpdatedAt() :
            $order->getCreatedAt());
        $handle = $this->_handlePostPurchaseState($order, $object);
        $trigger = $this->_triggerManager->createTrigger($this->getSiteId($order->getStoreId()), $messageType, $objectId);
        if (array_key_exists($objectId, $existingTriggers)) {
            $trigger = $existingTriggers[$objectId];
        }
        if ($handle === false) {
            $this->_triggerManager->delete($trigger);
        } else if ($handle === true && !$trigger->getSentMessage()) {
            $sendPeriod = $object['sendPeriod'];
            if (isset($object['multiply']) && $object['multiply'] === true) {
                $sendPeriod *= (int)$qtyOrdered;
            }
            $newTime = strtotime("+{$sendPeriod} days", $updatedAt);
            $this->_triggerManager->save($trigger
                ->setCustomerEmail($order->getCustomerEmail())
                ->setTriggeredAt($newTime)
                ->setModel($modelType, $modelId, $order->getStoreId()));
        }
    }

    /**
     * Deletes all of the triggers stored for deleted objects
     *
     * @param mixed $model
     * @return $model
     */
    protected function _deleteModelTrigger($model)
    {
        list($modelType, $modelId) = $this->_helper->getModelTuple($model);
        foreach ($this->_triggerManager->getTriggers($this->getSiteId($model->getStore()), $modelType, $modelId) as $trigger) {
            $this->_triggerManager->delete($trigger);
        }
        return $model;
    }

    /**
     * Determines the status movement by triggerable status and
     * changed data
     *
     * @param mixed $order
     * @param array $object
     * @return mixed
     */
    protected function _handlePostPurchaseState($order, $object)
    {
        $inAddStatus = $order->getStatus() == $object['triggerStatus'];
        $inCancelStatus = in_array($order->getStatus(), $object['cancelStatus']);
        if (!$inAddStatus && !$inCancelStatus) {
            return null;
        } else if ($inCancelStatus) {
            return false;
        } else {
            return $inAddStatus;
        }
    }

    /**
     * Gets the site hash for the store view
     *
     * @param mixed $store
     * @return string
     */
    protected function getSiteId($store)
    {
        if (is_null($this->_siteId)) {
            $this->_siteId = $this->_connectorSettings->getSiteId('store', $store);
        }
        return $this->_siteId;
    }
}
